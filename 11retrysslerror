import requests
import time
import pandas as pd
import os
import logging
import json
from datetime import datetime, timedelta, timezone
from tqdm import tqdm
from requests.adapters import HTTPAdapter, Retry


# =========================================================
# RETRY SESSION HELPER (with retries for SSL/server errors)
# =========================================================
def create_retry_session(
    retries=3,
    backoff_factor=1,
    status_forcelist=(502, 503, 504),
):
    """Create a requests session with retry logic for SSL/server errors."""
    session = requests.Session()
    retry = Retry(
        total=retries,
        read=retries,
        connect=retries,
        backoff_factor=backoff_factor,
        status_forcelist=status_forcelist,
        allowed_methods=["GET", "POST"],
        raise_on_status=False,  # don't raise exceptions on status codes
        respect_retry_after_header=True,
    )
    adapter = HTTPAdapter(max_retries=retry)
    session.mount("https://", adapter)
    session.mount("http://", adapter)
    return session


# =========================================================
# TOKEN SERVICE CLASS
# =========================================================
class SMSTokenService:
    def __init__(self, auth_url, client_id, client_secret, expire_in_seconds=1770):
        self.auth_url = auth_url
        self.client_id = client_id
        self.client_secret = client_secret
        self.expire_in = timedelta(seconds=expire_in_seconds)
        self.token = None
        self.expire_at = datetime.now(timezone.utc)
        self.session = create_retry_session()

    def token_valid(self):
        return self.token is not None and datetime.now(timezone.utc) < self.expire_at

    def renew_token(self):
        if not self.token_valid():
            logging.info("[AUTH] Requesting new access token...")
            payload = {
                "grant_type": "client_credentials",
                "client_id": self.client_id,
                "client_secret": self.client_secret
            }
            try:
                response = self.session.post(self.auth_url, data=payload)
                logging.info(f"[AUTH] Response Status: {response.status_code}")
                if response.status_code == 200:
                    token_data = response.json()
                    self.token = token_data.get("access_token")
                    self.expire_at = datetime.now(timezone.utc) + self.expire_in
                    logging.info("[AUTH] ✅ Access token received successfully.")
                else:
                    raise Exception(f"[AUTH ERROR] {response.status_code}: {response.text}")
            except requests.exceptions.RequestException as e:
                logging.error(f"[AUTH ERROR] Request failed: {str(e)}")
                raise Exception(f"[AUTH ERROR] Request failed: {str(e)}")

    def get_token(self):
        self.renew_token()
        return self.token

    def get_headers(self):
        return {
            "Authorization": f"Bearer {self.get_token()}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        }


# =========================================================
# MAIN CLASS - SMS DELIVERY REPORT
# =========================================================
class SMSDeliveryReport:
    def __init__(self, auth_url, client_id, client_secret, api_base, input_csv, output_csv, log_dir="logs"):
        self.api_base = api_base.rstrip("/")
        self.auth_url = auth_url
        self.input_csv = input_csv
        self.output_csv = output_csv
        self.phones_url = f"{self.api_base}/phones"
        self.outbound_url = f"{self.api_base}/outbound-messages"
        self.session = create_retry_session()

        # Setup Logging
        os.makedirs(log_dir, exist_ok=True)
        log_filename = os.path.join(
            log_dir,
            f"SMS_Delivery_Report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        )
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s [%(levelname)s] %(message)s",
            handlers=[
                logging.FileHandler(log_filename, encoding="utf-8"),
                logging.StreamHandler()
            ]
        )
        logging.info(f"📁 Log file created at: {log_filename}")

        # Token Service
        self.token_service = SMSTokenService(
            auth_url=self.auth_url,
            client_id=client_id,
            client_secret=client_secret
        )

    # =========================================================
    # PHONE LOOKUP
    # =========================================================
    def get_phone_id(self, number, country_code="US"):
        headers = self.token_service.get_headers()
        params = {"number": number, "country-code": country_code}

        logging.info(f"[LOOKUP] 🔍 Checking phone number: {number}")
        try:
            response = self.session.get(self.phones_url, headers=headers, params=params, timeout=20)
            logging.info(f"[LOOKUP] Status: {response.status_code}")

            # Skip server errors
            if 500 <= response.status_code <= 504:
                logging.error(f"[SERVER ERROR] {response.status_code} - Skipping this record.")
                return None

            if response.status_code == 200:
                phones = response.json().get("phone", [])
                if phones:
                    phone_id = phones[0]["id"]
                    logging.info(f"[LOOKUP] ✅ Found phone ID: {phone_id}")
                    return phone_id
                else:
                    logging.warning(f"[LOOKUP] ❌ No phone record found for {number}")
                    return None
            else:
                logging.warning(f"[LOOKUP] ⚠️ Unexpected response: {response.status_code} - {response.text}")
                return None

        except requests.exceptions.SSLError as e:
            logging.error(f"[LOOKUP SSL ERROR] {str(e)} — Retrying handled by session.")
            return "LOOKUP_ERROR"
        except requests.exceptions.RequestException as e:
            logging.error(f"[LOOKUP ERROR] {str(e)}")
            return "LOOKUP_ERROR"

    # =========================================================
    # OUTBOUND MESSAGE RETRIEVAL
    # =========================================================
    def get_outbound_messages(self, phone_id):
        headers = self.token_service.get_headers()
        all_messages = []
        page = 1
        per_page = 1000

        logging.info(f"[MESSAGES] 📩 Fetching outbound messages for phone ID: {phone_id}")

        while True:
            params = {"phone-id": phone_id, "per-page": per_page, "page": page}
            try:
                response = self.session.get(self.outbound_url, headers=headers, params=params, timeout=20)
                logging.info(f"[MESSAGES] Page {page} → Status: {response.status_code}")

                # Skip server errors
                if 500 <= response.status_code <= 504:
                    logging.error(f"[SERVER ERROR] {response.status_code} - Skipping this phone ID.")
                    break

                if response.status_code == 200:
                    data = response.json()
                    messages = data.get("outbound-message", [])

                    if not messages:
                        logging.info(f"[MESSAGES] ✅ No more messages after page {page - 1}.")
                        break

                    all_messages.extend(messages)
                    logging.info(f"[MESSAGES] Retrieved {len(messages)} messages from page {page}.")

                    if len(messages) < per_page:
                        break

                    page += 1
                    time.sleep(0.2)

                elif response.status_code == 422:
                    logging.info(f"[MESSAGES] ✅ No more pages (422). Stop at page {page - 1}.")
                    break
                else:
                    logging.warning(f"[MESSAGES] ⚠️ Unexpected status: {response.status_code}")
                    break

            except requests.exceptions.SSLError as e:
                logging.error(f"[MESSAGES SSL ERROR] {str(e)} — Retrying handled by session.")
                break
            except requests.exceptions.RequestException as e:
                logging.error(f"[MESSAGES ERROR] {str(e)}")
                break

        logging.info(f"[MESSAGES] 📦 Total messages fetched for phone ID {phone_id}: {len(all_messages)}")
        return all_messages

    # =========================================================
    # MAIN REPORT PROCESS
    # =========================================================
    def generate_report(self):
        df = pd.read_csv(self.input_csv)
        results = []
        total = len(df)
        logging.info(f"\n🚀 Starting SMS Delivery Report generation for {total} members...\n")

        for _, row in tqdm(df.iterrows(), total=total, desc="Processing phones", unit="record"):
            phone = str(row["MEMBER_PHONE"]).strip()
            country = str(row.get("COUNTRY_CODE", "US")).strip()
            gmpi_id = str(row.get("GMPI_ID", "")).strip()
            first_name = str(row.get("MEMBER_FIRST_NAME", "")).strip()
            last_name = str(row.get("MEMBER_LAST_NAME", "")).strip()

            try:
                phone_id = self.get_phone_id(phone, country)

                if phone_id == "LOOKUP_ERROR":
                    results.append({
                        "GMPI_ID": gmpi_id,
                        "Phone_id": "",
                        "Phone_Number": phone,
                        "First_Name": first_name,
                        "Last_Name": last_name,
                        "Service Response Status": "",
                        "API Response Status": "LOOKUP_ERROR",
                        "Deliver_on": "",
                        "expire_at": "",
                        "created_at": "",
                        "updated_at": "",
                        "program_id": "",
                        "template_id": ""
                    })
                    continue

                if not phone_id:
                    results.append({
                        "GMPI_ID": gmpi_id,
                        "Phone_id": "",
                        "Phone_Number": phone,
                        "First_Name": first_name,
                        "Last_Name": last_name,
                        "Service Response Status": "",
                        "API Response Status": "NOT_FOUND",
                        "Deliver_on": "",
                        "expire_at": "",
                        "created_at": "",
                        "updated_at": "",
                        "program_id": "",
                        "template_id": ""
                    })
                    continue

                messages = self.get_outbound_messages(phone_id)
                if not messages:
                    results.append({
                        "GMPI_ID": gmpi_id,
                        "Phone_id": phone_id,
                        "Phone_Number": phone,
                        "First_Name": first_name,
                        "Last_Name": last_name,
                        "Service Response Status": "",
                        "API Response Status": "NO_MESSAGES",
                        "Deliver_on": "",
                        "expire_at": "",
                        "created_at": "",
                        "updated_at": "",
                        "program_id": "",
                        "template_id": ""
                    })
                    continue

                for msg in messages:
                    carrier_status = ""
                    try:
                        service_response = msg.get("service-response", "")
                        if service_response:
                            carrier_status = json.loads(service_response).get("status", "")
                    except Exception:
                        carrier_status = "PARSE_ERROR"

                    results.append({
                        "GMPI_ID": gmpi_id,
                        "Phone_id": msg.get("phone-id", ""),
                        "Phone_Number": phone,
                        "First_Name": first_name,
                        "Last_Name": last_name,
                        "Service Response Status": carrier_status,
                        "API Response Status": msg.get("status", ""),
                        "Deliver_on": msg.get("deliver-on", ""),
                        "expire_at": msg.get("expire-at", ""),
                        "created_at": msg.get("created-at", ""),
                        "updated_at": msg.get("updated-at", ""),
                        "program_id": msg.get("program-id", ""),
                        "template_id": msg.get("template-id", "")
                    })

            except Exception as e:
                logging.error(f"[ERROR] ❌ Processing {phone}: {str(e)}")
                results.append({
                    "GMPI_ID": gmpi_id,
                    "Phone_id": "",
                    "Phone_Number": phone,
                    "First_Name": first_name,
                    "Last_Name": last_name,
                    "Service Response Status": "",
                    "API Response Status": f"ERROR: {str(e)}",
                    "Deliver_on": "",
                    "expire_at": "",
                    "created_at": "",
                    "updated_at": "",
                    "program_id": "",
                    "template_id": ""
                })

            time.sleep(0.3)

        output_df = pd.DataFrame(results)[[
            "GMPI_ID",
            "Phone_id",
            "Phone_Number",
            "First_Name",
            "Last_Name",
            "Service Response Status",
            "API Response Status",
            "Deliver_on",
            "expire_at",
            "created_at",
            "updated_at",
            "program_id",
            "template_id"
        ]]

        dated_filename = f"SMSDelivery_Report_{datetime.now().strftime('%m%d%Y')}.csv"
        output_df.to_csv(dated_filename, index=False)
        logging.info(f"\n✅ SMS Delivery Report generated successfully: {dated_filename}")


# =========================================================
# MAIN ENTRY
# =========================================================
if __name__ == "__main__":

    AUTH_URL = ""  # Replace with actual auth endpoint
    CLIENT_ID = ""
    CLIENT_SECRET = ""
    API_BASE_URL = ""  # Base API URL

    INPUT_CSV = "Member_Phone_List_10162025.csv"
    OUTPUT_CSV = "SMSDelivery_Report.csv"

    report = SMSDeliveryReport(
        auth_url=AUTH_URL,
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET,
        api_base=API_BASE_URL,
        input_csv=INPUT_CSV,
        output_csv=OUTPUT_CSV
    )

    report.generate_report()
